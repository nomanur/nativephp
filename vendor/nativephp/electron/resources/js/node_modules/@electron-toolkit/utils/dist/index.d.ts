import { BrowserWindow } from 'electron';
import { IpcMainEvent } from 'electron';
import { IpcMainInvokeEvent } from 'electron';

export declare type ChromeExtension = 'ANGULARJS_BATARANG' | 'REACT_DEVELOPER_TOOLS' | 'REDUX_DEVTOOLS' | 'VUEJS3_DEVTOOLS' | 'VUEJS_DEVTOOLS';

export declare interface ChromeExtensionOptions {
    forceDownload?: boolean;
    allowFileAccess?: boolean;
}

export declare interface DevTools {
    install: (extensionId: ChromeExtension, options?: ChromeExtensionOptions) => Promise<void>;
}

export declare const devTools: DevTools;

export declare interface ElectronApp {
    /**
     * Changes the Application User Model ID to id.
     *
     * The `id` is used only when the applcation is packaged. otherwise use the
     * `process.execPath` value as id.
     *
     * see https://www.electronjs.org/docs/latest/tutorial/notifications#windows
     * @platform — win32
     */
    setAppUserModelId: (id: string) => void;
    /**
     * Whether the call succeeded.
     *
     * Set the app open at login or not.
     *
     *  **Note:** `false` always on Linux.
     * @platform — darwin,win32
     */
    setAutoLaunch: (auto: boolean) => boolean;
    /**
     * Skip proxy for Electron app.
     */
    skipProxy: () => Promise<void>;
}

export declare const electronApp: ElectronApp;

export declare interface IpcHelper {
    /**
     * Adds a handler for an `invoke`able IPC. This handler will be called whenever a
     * renderer calls `ipcRenderer.invoke(channel, ...args)`.
     *
     * If `listener` returns a Promise, the eventual result of the promise will be
     * returned as a reply to the remote caller. Otherwise, the return value of the
     * listener will be used as the value of the reply.
     *
     * The `event` that is passed as the first argument to the handler is the same as
     * that passed to a regular event listener. It includes information about which
     * WebContents is the source of the invoke request.
     *
     * Errors thrown through `handle` in the main process are not transparent as they
     * are serialized and only the `message` property from the original error is
     * provided to the renderer process. Please refer to #24427 for details.
     */
    handle(channel: string, listener: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<void> | any): void;
    /**
     * Listens to `channel`, when a new message arrives `listener` would be called with
     * `listener(event, args...)`.
     */
    on(channel: string, listener: (event: IpcMainEvent, ...args: any[]) => void): this;
    /**
     * Remove all register ipc listeners.
     */
    removeAllListeners(): this;
    /**
     * Remove all register ipc handlers.
     */
    removeAllHandlers(): void;
    /**
     * Remove ipc listeners.
     */
    removeListeners(channels: string[]): this;
    /**
     * Remove ipc handlers.
     */
    removeHandlers(channels: string[]): void;
}

export declare const ipcHelper: IpcHelper;

export declare interface Is {
    dev: boolean;
}

export declare const is: Is;

export declare interface Optimizer {
    /**
     * Default open or close DevTools by `F12` in development and
     * ignore `CommandOrControl + R` in production.
     *
     * Use `shortcutOptions` to control more shortcuts.
     */
    watchWindowShortcuts: (window: BrowserWindow, shortcutOptions?: shortcutOptions) => void;
    /**
     * If use a frameless window which hide the system's native window controls,
     * we may need to create custom window controls in HTML.
     *
     * The frameless window ipc allow the renderer process to control the
     * browser window.
     *
     * The ipc channel named `win:invoke`.
     *
     * For Example:
     *
     * ```
     * ipcRenderer.send('win:invoke', 'show')
     * ipcRenderer.send('win:invoke', 'showInactive')
     * ipcRenderer.send('win:invoke', 'min')
     * ipcRenderer.send('win:invoke', 'max')
     * ipcRenderer.send('win:invoke', 'close')
     * ```
     */
    registerFramelessWindowIpc: () => void;
}

export declare const optimizer: Optimizer;

export declare interface Platform {
    isWindows: boolean;
    isMacOS: boolean;
    isLinux: boolean;
}

export declare const platform: Platform;

export declare type shortcutOptions = {
    /**
     * Use `ESC` key to close window, default `false`.
     */
    escToCloseWindow: boolean;
    /**
     * Zoom in (`Minus + CommandOrControl`) or zoom out(`Equal + Shift + CommandOrControl`), default `false`.
     */
    zoom: boolean;
};

export { }
