'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var electron = require('electron');
var path = require('path');
var fs = require('fs');
var https = require('https');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);

const is = {
    dev: !electron.app.isPackaged
};

const platform = {
    isWindows: process.platform === 'win32',
    isMacOS: process.platform === 'darwin',
    isLinux: process.platform === 'linux'
};

// see https://github.com/Rob--W/crxviewer/blob/master/src/lib/crx-to-zip.js
const crxToZip = (arraybuffer) => {
    const calcLength = (a, b, c, d) => {
        let length = 0;
        length += a << 0;
        length += b << 8;
        length += c << 16;
        length += (d << 24) >>> 0;
        return length;
    };
    // Definition of crx format: http://developer.chrome.com/extensions/crx.html
    const view = new Uint8Array(arraybuffer);
    // 50 4b 03 04
    if (view[0] === 80 && view[1] === 75 && view[2] === 3 && view[3] === 4) {
        console.warn('Input is not a CRX file, but a ZIP file.');
        const buffer = Buffer.from(arraybuffer);
        return Uint8Array.from(buffer).buffer;
    }
    // 43 72 32 34
    if (view[0] !== 67 || view[1] !== 114 || view[2] !== 50 || view[3] !== 52) {
        throw new Error('Invalid header: Does not start with PK\\x03\\x04 or Cr24\n\n');
    }
    // 02 00 00 00
    // 03 00 00 00 CRX3
    if ((view[4] !== 2 && view[4] !== 3) || view[5] || view[6] || view[7]) {
        throw new Error('Unexpected crx format version number.');
    }
    let zipStartOffset;
    if (view[4] === 2) {
        const publicKeyLength = calcLength(view[8], view[9], view[10], view[11]);
        const signatureLength = calcLength(view[12], view[13], view[14], view[15]);
        // 16 = Magic number (4), CRX format version (4), lengths (2x4)
        zipStartOffset = 16 + publicKeyLength + signatureLength;
    }
    else {
        // view[4] === 3
        // CRX3 - https://cs.chromium.org/chromium/src/components/crx_file/crx3.proto
        const crx3HeaderLength = calcLength(view[8], view[9], view[10], view[11]);
        // 12 = Magic number (4), CRX format version (4), header length (4)
        zipStartOffset = 12 + crx3HeaderLength;
    }
    // Create a new view for the existing buffer, and wrap it in a Blob object.
    const buffer = Buffer.from(new Uint8Array(arraybuffer, zipStartOffset));
    return Uint8Array.from(buffer).buffer;
};
const unzipCrx = (crxFilePath, destination) => {
    const filePath = path__default["default"].resolve(crxFilePath);
    const extname = path__default["default"].extname(crxFilePath);
    const basename = path__default["default"].basename(crxFilePath, extname);
    const dirname = path__default["default"].dirname(crxFilePath);
    destination = destination || path__default["default"].resolve(dirname, basename);
    const jszip = require('jszip');
    return fs.promises
        .readFile(filePath)
        .then(buf => jszip.loadAsync(crxToZip(buf)))
        .then(zip => {
        const zipFileKeys = Object.keys(zip.files);
        return Promise.all(zipFileKeys.map(async (filename) => {
            const isFile = !zip.files[filename].dir;
            const fullPath = path__default["default"].join(destination, filename);
            const directory = (isFile && path__default["default"].dirname(fullPath)) || fullPath;
            const content = zip.files[filename].async('nodebuffer');
            await fs.promises.mkdir(directory, { recursive: true });
            if (isFile) {
                const data = await content;
                if (data) {
                    return fs.promises.writeFile(fullPath, data);
                }
                else {
                    return true;
                }
            }
        }));
    });
};

const getCachePath = () => {
    return path__default["default"].resolve(electron.app.getPath('userData'), 'CachedExtensions');
};
const mkdir = (path) => {
    if (!fs__default["default"].existsSync(path)) {
        fs__default["default"].mkdirSync(path, { recursive: true });
    }
};
const rmdir = (dir) => {
    const names = fs__default["default"].readdirSync(dir) || [];
    names.forEach(name => {
        const _path = path__default["default"].join(dir, name);
        const i = fs__default["default"].statSync(_path);
        if (i.isDirectory()) {
            rmdir(_path);
        }
        else {
            try {
                fs__default["default"].unlinkSync(_path);
            }
            catch (e) {
                console.log();
            }
        }
    });
    try {
        fs__default["default"].rmdirSync(dir);
    }
    catch (e) {
        console.log();
    }
};
const dl = (url, savePath) => {
    return new Promise((resolve, reject) => {
        const failed = (err) => reject(err);
        const request = https__default["default"].get(url);
        request.on('response', res => {
            if (res.statusCode === 200) {
                res.pipe(fs__default["default"].createWriteStream(savePath)).on('close', resolve);
                res.on('error', failed);
            }
            else if (res.statusCode === 302 && res.headers.location) {
                dl(res.headers.location, savePath).then(resolve).catch(failed);
            }
            else {
                failed(`Error: download extension response with ${res.statusCode}`);
            }
        });
        request.on('error', failed);
        request.end();
    });
};
const downloadChromeExtension = (extensionId) => {
    return new Promise((resolve, reject) => {
        const cachePath = getCachePath();
        mkdir(cachePath);
        const extensionDir = path__default["default"].resolve(cachePath, extensionId);
        if (fs__default["default"].existsSync(extensionDir))
            rmdir(extensionDir);
        const url = `https://clients2.google.com/service/update2/crx?response=redirect&acceptformat=crx2,crx3&x=id%3D${extensionId}%26uc&prodversion=32`; // eslint-disable-line
        const savePath = path__default["default"].resolve(cachePath, `${extensionId}.crx`);
        dl(url, savePath)
            .then(() => unzipCrx(savePath, extensionDir))
            .then(() => resolve(extensionDir))
            .catch(e => {
            if (fs__default["default"].existsSync(extensionDir))
                rmdir(extensionDir);
            console.error('Install extension failed.\n', e);
            reject();
        });
    });
};
const chromeExtensions = {
    ANGULARJS_BATARANG: 'ighdmehidhipcmcojjgiloacoafjmpfk',
    REACT_DEVELOPER_TOOLS: 'fmkadmapgofadopljbjfkapdkoienihi',
    REDUX_DEVTOOLS: 'lmhkpmbekcpmknklioeibfkpmmfibljd',
    VUEJS3_DEVTOOLS: 'ljjemllljcmogpfapbkkighbhhppjdbg',
    VUEJS_DEVTOOLS: 'nhdogjmejiglipccpnnnanhbledajbpd'
};
const devTools = {
    install: async (extensionId, options) => {
        if (!is.dev || !electron.app.isReady() || process.type !== 'browser')
            return;
        const chromeExtensionId = chromeExtensions[extensionId];
        if (!chromeExtensionId) {
            console.error('Invalid extension');
            return;
        }
        if (electron.session.defaultSession.getExtension(chromeExtensionId)) {
            console.warn('Extension installed');
            return;
        }
        const cacheDir = getCachePath();
        let extensionDir = path__default["default"].resolve(cacheDir, chromeExtensionId);
        if (!fs__default["default"].existsSync(extensionDir) || (options === null || options === void 0 ? void 0 : options.forceDownload)) {
            try {
                extensionDir = await downloadChromeExtension(chromeExtensionId);
            }
            catch {
                extensionDir = '';
            }
        }
        const loadExtensionOptions = {
            allowFileAccess: (options === null || options === void 0 ? void 0 : options.allowFileAccess) || false
        };
        if (extensionDir)
            electron.session.defaultSession.loadExtension(extensionDir, loadExtensionOptions);
    }
};

const electronApp = {
    setAppUserModelId(id) {
        if (platform.isWindows)
            electron.app.setAppUserModelId(is.dev ? process.execPath : id);
    },
    setAutoLaunch(auto) {
        if (platform.isLinux)
            return false;
        const isOpenAtLogin = () => {
            return electron.app.getLoginItemSettings().openAtLogin;
        };
        if (isOpenAtLogin() !== auto) {
            electron.app.setLoginItemSettings({
                openAtLogin: auto,
                path: process.execPath
            });
            return isOpenAtLogin() === auto;
        }
        else {
            return true;
        }
    },
    skipProxy() {
        return electron.session.defaultSession.setProxy({ mode: 'direct' });
    }
};

/* eslint-disable  @typescript-eslint/no-explicit-any */
let listeners = [];
let handlers = [];
const ipcHelper = {
    handle(channel, listener) {
        handlers.push(channel);
        electron.ipcMain.handle(channel, listener);
    },
    on(channel, listener) {
        listeners.push(channel);
        electron.ipcMain.on(channel, listener);
        return this;
    },
    removeAllListeners() {
        listeners.forEach(c => electron.ipcMain.removeAllListeners(c));
        listeners = [];
        return this;
    },
    removeAllHandlers() {
        handlers.forEach(c => electron.ipcMain.removeHandler(c));
        handlers = [];
    },
    removeListeners(channels) {
        channels.forEach(c => electron.ipcMain.removeAllListeners(c));
        return this;
    },
    removeHandlers(channels) {
        channels.forEach(c => electron.ipcMain.removeHandler(c));
    }
};

const optimizer = {
    watchWindowShortcuts(window, shortcutOptions) {
        if (!window)
            return;
        const { webContents } = window;
        const { escToCloseWindow = false, zoom = false } = shortcutOptions || {};
        webContents.on('before-input-event', (event, input) => {
            if (input.type === 'keyDown') {
                if (!is.dev) {
                    // Ignore CommandOrControl + R
                    if (input.key === 'r' && (input.control || input.meta))
                        event.preventDefault();
                }
                else {
                    // Toggle devtool(F12)
                    if (input.code === 'F12') {
                        if (webContents.isDevToolsOpened()) {
                            webContents.closeDevTools();
                        }
                        else {
                            webContents.openDevTools();
                            console.log('Open dev tool...');
                        }
                    }
                }
                if (escToCloseWindow) {
                    if (input.code === 'Escape' && input.key !== 'Process') {
                        window.close;
                        event.preventDefault();
                    }
                }
                if (!zoom) {
                    // Disable zoom in
                    if (input.code === 'Minus' && (input.control || input.meta))
                        event.preventDefault();
                    // Disable zoom out
                    if (input.code === 'Equal' && input.shift && (input.control || input.meta))
                        event.preventDefault();
                }
            }
        });
    },
    registerFramelessWindowIpc() {
        electron.ipcMain.on('win:invoke', (event, action) => {
            const win = electron.BrowserWindow.fromWebContents(event.sender);
            if (win) {
                if (action === 'show') {
                    win.show();
                }
                else if (action === 'showInactive') {
                    win.showInactive();
                }
                else if (action === 'min') {
                    win.minimize();
                }
                else if (action === 'max') {
                    const isMaximized = win.isMaximized();
                    if (isMaximized) {
                        win.unmaximize();
                    }
                    else {
                        win.maximize();
                    }
                }
                else if (action === 'close') {
                    win.close();
                }
            }
        });
    }
};

exports.devTools = devTools;
exports.electronApp = electronApp;
exports.ipcHelper = ipcHelper;
exports.is = is;
exports.optimizer = optimizer;
exports.platform = platform;
